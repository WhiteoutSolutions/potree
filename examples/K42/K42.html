<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="description" content="">
	<meta name="author" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<title>Potree Viewer</title>

	<link rel="stylesheet" type="text/css" href="../../build/potree/potree.css">
	<link rel="stylesheet" type="text/css" href="../../libs/jquery-ui/jquery-ui.min.css">
	<link rel="stylesheet" type="text/css" href="../../libs/openlayers3/ol.css">
	<link rel="stylesheet" type="text/css" href="../../libs/spectrum/spectrum.css">
	<link rel="stylesheet" type="text/css" href="../../libs/jstree/themes/mixed/style.css">
</head>

<body>
	<script src="../../libs/jquery/jquery-3.1.1.min.js"></script>
	<script src="../../libs/spectrum/spectrum.js"></script>
	<script src="../../libs/jquery-ui/jquery-ui.min.js"></script>
	<script src="../../libs/other/BinaryHeap.js"></script>
	<script src="../../libs/tween/tween.min.js"></script>
	<script src="../../libs/d3/d3.js"></script>
	<script src="../../libs/proj4/proj4.js"></script>
	<script src="../../libs/openlayers3/ol.js"></script>
	<script src="../../libs/i18next/i18next.js"></script>
	<script src="../../libs/jstree/jstree.js"></script>
	<script src="../../build/potree/potree.js"></script>
	<script src="../../libs/plasio/js/laslaz.js"></script>
	<script src="../../libs/shapefile/shapefile.js"></script>

	<script src="../../libs/geotiff.js/geotiff.js"></script>
	<script src="../../libs/geotiff-geokeys-to-proj4/main-dist.js"></script>



	
	<!-- INCLUDE ADDITIONAL DEPENDENCIES HERE -->
	<!-- INCLUDE SETTINGS HERE -->
	
	<div class="potree_container" style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px; ">
		<div id="potree_render_area" style="background-image: url('../build/potree/resources/images/background.jpg');"></div>
		<div id="potree_sidebar_container"> </div>
	</div>
	
	<script type="module">

		import * as THREE from "../../libs/three.js/build/three.module.js";

		//const geotiff = require("geotiff"); // geotiff.js
		//const proj4 = require("proj4"); // proj4js
		//const geokeysToProj4 = require("geotiff-geokeys-to-proj4"); // This library
	
		window.viewer = new Potree.Viewer(document.getElementById("potree_render_area"));
		
		//viewer.setServer("http://localhost:3000");
		
		viewer.setEDLEnabled(false);
		viewer.setFOV(60);
		viewer.setPointBudget(10_000_000);
		viewer.loadSettingsFromURL();
		
		viewer.setDescription('San Simeon, CA Central Coast point cloud taken from <a href="http://opentopo.sdsc.edu/gridsphere/gridsphere?cid=geonlidarframeportlet&gs_action=lidarDataset&opentopoID=OTLAS.032013.26910.2" target="_blank">Open Topography</a> (17.7b points)');
		
		viewer.loadGUI(() => {
			viewer.setLanguage('en');
			$("#menu_tools").next().show();
			$("#menu_scene").next().show();
			viewer.toggleSidebar();
		});
		
		// Load and add point cloud to scene
		Potree.loadPointCloud("./metadata.json", "CA13", async e => {

			let scene = viewer.scene;
			let pointcloud = e.pointcloud;
			let material = pointcloud.material;
			scene.addPointCloud(pointcloud);
			
			material.pointSizeType = Potree.PointSizeType.FIXED;
			material.size = 1;
			
			viewer.setBackView();
			
			//scene.view.position.set(697757.85, 3913444.33, 2827.33);
			//scene.view.lookAt(new THREE.Vector3(695231.74, 3916988.94, 87.64));
			
			if(true){
				// define the transformation from shapefile to point cloud coordinate systems
				//proj4.defs("WGS84", pointcloud.projection);
				//proj4.defs("pointcloud", pointcloud.projection);
				//let transform = proj4("WGS84", "pointcloud");

				const loader = new Potree.ShapefileLoader();
				//loader.transform = transform;

				// group all shapefile scene nodes into this node
				const shapeNode = new THREE.Object3D();
				viewer.scene.scene.add(shapeNode);


				// load K42_clip_segmented.shp
				const shpPoints = await loader.load("./shapefiles/K42_clip_segmented.shp");
				shapeNode.add(shpPoints.node);

				// this is necessary so that fat lines are correctly sized
				viewer.addEventListener("update", () => {
					const size = viewer.renderer.getSize(new THREE.Vector2());

					shpPoints.setResolution(size.width, size.height);
				});


				viewer.onGUILoaded(() => {
					// Add entry to object list in sidebar
					let tree = $(`#jstree_scene`);
					let parentNode = "other";

					let shpPointsID = tree.jstree('create_node', parentNode, { 
							"text": "points", 
							"icon": `${Potree.resourcePath}/icons/triangle.svg`,
							"object": shpPoints.node,
							"data": shpPoints.node,
						}, 
						"last", false, false);
					tree.jstree(shpPoints.node.visible ? "check_node" : "uncheck_node", shpPointsID);
				});
				
			}
		});

		// Let's wrap our example in a function
		async function workWithGeoTIFF(tiffUrl) {
			console.log("Starting to work with geotiff");
			// Read image. See geotiff.js docs on what all of that means.
			//let tiff = await geotiff.fromBlob(blob); // Read blob
  			const tiff = await GeoTIFF.fromUrl(tiffUrl);
			let imageCount = await tiff.getImageCount(); // Get image count
			console.log("Found " + imageCount + " images.");

			// Work with each image in a file
			for (let i = 0; i < imageCount; i++) {
				let image = await tiff.getImage(i); // Get image instance
				let geoKeys = image.getGeoKeys(); // Get geokeys
				let projObj = geokeysToProj4.toProj4(geoKeys); // Convert geokeys to proj4 string
				// The function above returns an object where proj4 property is a Proj4 string and coordinatesConversionParameters is conversion parameters which we'll use later
				console.log("Geotiff projection: " + projObj.proj4);
				let projection = proj4(projObj.proj4, "+proj=tmerc +lat_0=42.5 +lon_0=-72.5 +k=0.999964286 +x_0=500000.00001016 +y_0=0 +ellps=GRS80 +units=us-ft +no_defs"); // Project our GeoTIFF to WGS84

				// Now you may want to deal with errors. Unfortunately, errors are unavoidable, but in most cases, you can warn the user or just continue on.
				// All occurred errors will be in projObj.errors object. See the docs for more information:
				// https://matafokka.github.io/geotiff-geokeys-to-proj4/module-geokeysToProj4.html#.ConversionErrors__anchor

				// Work with pixels
				// For looping over pixels
				const width = image.getWidth(), height = image.getHeight(),
				// Pixel dimensions for converting image coordinates to source CRS coordinates
				[originX, originY] = image.getOrigin(), [xSize, ySize] = image.getResolution();

				// Rest of the coordinates for the top and left sides. Needed to determine pixel position.
				const rightX = originX + width * xSize, bottomY = originY + height * ySize;

				// Build bounding rect, image polygon and data for further math

				// Original image rectangle
				const origPoints = [
					[originX, originY],
					[rightX, originY],
					[originX + width * xSize, originY + height * ySize],
					[originX, bottomY],
					[originX, originY],
				];

				// Projected image rectangle
				let projPoints = [];
				let pointsArray = [];
				for (let point of origPoints){
					projPoints.push(projection.forward(point));
					pointsArray.push(point[0]);
					pointsArray.push(point[1]);
					pointsArray.push(0);
				}

				// Bounding rect to detect whether image should be read later
				//const boundingRect = Rectangle.fromDegrees(...bbox(polygon([projPoints])));
				console.log("origPoints: " + JSON.stringify(origPoints));
				console.log("pointsArray: " + JSON.stringify(pointsArray));
				//console.log("Bounding box: " + JSON.stringify(projPoints));

				const geometry = new THREE.BufferGeometry();
				const vertices = new Float32Array(pointsArray);
				geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
				const material = new THREE.MeshBasicMaterial( { color: 0xff00ff, side: THREE.DoubleSide } );
				const mesh1 = new THREE.Mesh( geometry, material );
				viewer.scene.scene.add(mesh1);

				console.log("Loading raster");
				const imageData = new ((await image.readRasters([0, 1, 0, 1]))[0]).constructor(width * height);
				console.log("Raster loaded");

				// Read rows
				/*for (let y = 0; y < height; y++) {
					// Read one row of pixels. Easier to deal with coordinates, takes less RAM.
					let raster = await image.readRasters({window: [0, y, width, y + 1]});
					let color0 = raster[0]; // Raster is a TypedArray where elements are colors and their elements are pixel values of that color

					// Read columns. Since we're reading full row, we can replace color0.length with width, but I find color0.length more explicit.
					for (let x = 0; i < color0.length; x++) {
					
						// Convert current pixel's coordinates to CRS by:
						// 1. Multiplying current coordinates by pixel size which will result in distance from top-left corner in CRS units.
						// 2. Adding this value to top-left corner coordinates which will result in "global" coordinates in CRS units.
						// This will work because image is transformed by Affine Transformation which preserves parallelism.
						// Warning: this logic works only for source CRS, target CRS might screw up parallel lines, so pixel dimensions will not be constant!
						let crsX = originX + x * xSize, crsY = originY + y * ySize;

						// Check if coordinates are already in meters (or other "standard" units). If not, convert them.
						// You can remove the condition, if you consider it as premature optimisation, convertCoordinates() will work just fine in any case.
						let point;
						if (projObj.shouldConvertCoordinates)
							point = geokeysToProj4.convertCoordinates(crsX, crsY, projObj.coordinatesConversionParameters);
						else
							point = {x: crsX, y: crsY};

						// Or just multiply manually to speed up execution by removing function calls:
						point = {
							x: crsX * projObj.coordinatesConversionParameters.x,
							y: crsY * projObj.coordinatesConversionParameters.y,
						}

						let projectedPoint = projection.forward(point); // Project these coordinates
						console.log("Found point coordinate: " + projectedPoint);
						// Work with projected coordinates...
					}
				}*/
			}
		}

		workWithGeoTIFF("./geotiffs/Clip_Exportedk42TestImage22.tif");
		
	</script>
	
	
  </body>
</html>
